<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Interview Common Questions]]></title>
      <url>http://LyricistPKU.github.io/2017/08/18/Interview-Common-Questions/</url>
      <content type="html"><![CDATA[<p>Anything about the interview preparing. Still Updating…<br><a id="more"></a></p>
<h1 id="C-面试题"><a href="#C-面试题" class="headerlink" title="C++面试题"></a>C++面试题</h1><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h3><p>变量的定义：为变量分配存储空间（还可以有初始值），定义只能一次<br>变量的声明：向编译器表明变量的类型和名字，声明可以多次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extern int i;	//变量声明未定义</div><div class="line">int i;	//变量声明且定义，未初始化，对于全局变量编译器会赋初值，局部变量未初始化会有意想不到的结果</div><div class="line">//static变量不论是全局还是局部都会有初值</div><div class="line">void fun();		//函数声明</div><div class="line">void fun()&#123;&#125;	//函数定义</div><div class="line">//模板函数声明和定义必须同时在.h文件当中，函数被使用时编译器需要在编译阶段进行模板类型检查而不是在链接阶段找到函数的定义</div></pre></td></tr></table></figure></p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ol>
<li>模板的特化（如果Equal函数对于float和double类型的执行需要特殊处理，就必须特化这两个类型）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">template &lt;class T&gt;</div><div class="line">class TClass</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     bool Equal(const T&amp; arg, const T&amp; arg1);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;class T&gt;</div><div class="line">bool TClass&lt;T&gt;::Equal(const T&amp; arg, const T&amp; arg1)</div><div class="line">&#123;</div><div class="line">     return (arg == arg1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">     TClass&lt;int&gt; obj;</div><div class="line">     cout&lt;&lt;obj.Equal(2, 2)&lt;&lt;endl;</div><div class="line">     cout&lt;&lt;obj.Equal(2, 4)&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">template &lt;class T&gt;</div><div class="line">class Compare</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     bool IsEqual(const T&amp; arg, const T&amp; arg1);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 已经不具有template的意思了，已经明确为float了</div><div class="line">template &lt;&gt;</div><div class="line">class Compare&lt;float&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     bool IsEqual(const float&amp; arg, const float&amp; arg1);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 已经不具有template的意思了，已经明确为double了</div><div class="line">template &lt;&gt;</div><div class="line">class Compare&lt;double&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     bool IsEqual(const double&amp; arg, const double&amp; arg1);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;class T&gt;</div><div class="line">bool Compare&lt;T&gt;::IsEqual(const T&amp; arg, const T&amp; arg1)</div><div class="line">&#123;</div><div class="line">     cout&lt;&lt;&quot;Call Compare&lt;T&gt;::IsEqual&quot;&lt;&lt;endl;</div><div class="line">     return (arg == arg1);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">bool Compare&lt;float&gt;::IsEqual(const float&amp; arg, const float&amp; arg1)</div><div class="line">&#123;</div><div class="line">     cout&lt;&lt;&quot;Call Compare&lt;float&gt;::IsEqual&quot;&lt;&lt;endl;</div><div class="line">     return (abs(arg - arg1) &lt; 10e-3);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">bool Compare&lt;double&gt;::IsEqual(const double&amp; arg, const double&amp; arg1)</div><div class="line">&#123;</div><div class="line">     cout&lt;&lt;&quot;Call Compare&lt;double&gt;::IsEqual&quot;&lt;&lt;endl;</div><div class="line">     return (abs(arg - arg1) &lt; 10e-6);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">     Compare&lt;int&gt; obj;</div><div class="line">     Compare&lt;float&gt; obj1;</div><div class="line">     Compare&lt;double&gt; obj2;</div><div class="line">     cout&lt;&lt;obj.IsEqual(2, 2)&lt;&lt;endl;</div><div class="line">     cout&lt;&lt;obj1.IsEqual(2.003, 2.002)&lt;&lt;endl;</div><div class="line">     cout&lt;&lt;obj2.IsEqual(3.000002, 3.0000021)&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>模板的偏特化（特化的模板其实已经不算是模板了，偏特化可以针对不同类型定义各自模板）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 一般化设计</div><div class="line">template &lt;class T, class T1&gt;</div><div class="line">class TestClass</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     TestClass()</div><div class="line">     &#123;</div><div class="line">          cout&lt;&lt;&quot;T, T1&quot;&lt;&lt;endl;</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 针对普通指针的偏特化设计</div><div class="line">template &lt;class T, class T1&gt;</div><div class="line">class TestClass&lt;T*, T1*&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     TestClass()</div><div class="line">     &#123;</div><div class="line">          cout&lt;&lt;&quot;T*, T1*&quot;&lt;&lt;endl;</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 针对const指针的偏特化设计</div><div class="line">template &lt;class T, class T1&gt;</div><div class="line">class TestClass&lt;const T*, T1*&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     TestClass()</div><div class="line">     &#123;</div><div class="line">          cout&lt;&lt;&quot;const T*, T1*&quot;&lt;&lt;endl;</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">     TestClass&lt;int, char&gt; obj;</div><div class="line">     TestClass&lt;int *, char *&gt; obj1;</div><div class="line">     TestClass&lt;const int *, char *&gt; obj2;</div><div class="line"> </div><div class="line">     return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="C-常见关键字"><a href="#C-常见关键字" class="headerlink" title="C++常见关键字"></a>C++常见关键字</h3><ol>
<li>inline：把函数定义放在符号表中，调用时可以直接替换（注意：inline放在函数声明前无用，必须放在函数定义前）；类中定义的函数编译器在调用处可以自动执行inline的功能，类外定义的（类）函数使用inline发挥该功能</li>
<li><p>typedef与#define：#define定义的宏在编译预处理时被简单替换，不做正确性检查，编译已展开的源程序时报错；typedef给类型定义别名，编译时检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef int* ptr;</div><div class="line">const ptr p;	//p不可更改，但是p指向的内容可以</div><div class="line">#define PTR int*</div><div class="line">const PTR p;	//p可以更改，但是p指向的内容不可以</div></pre></td></tr></table></figure>
</li>
<li><p>static：(a)类外static：函数内static变量只分配一次内存；模块内static变量之内被模块内函数访问（文件作用域）；模块内的static函数只能被模块内的其他函数调用；(b)类内static：类内的static变量对整个类来说只有一份拷贝；类内的static函数为整个类所有，不接受this指针，因此只能访问static成员变量</p>
</li>
<li>const：(a)类外const：可以修饰指针本身或指向对象不可变；函数声明中形参用const，函数内不能改变；对于不想改变的变量可以用const修饰，通常需要初始化；(b)类内const：const成员函数不改变成员变量；返回const值的成员函数，其返回值不能为等式左值；<br><strong>static和const变量初始化问题：类中的static变量初始化要在类外，类名::变量名=值；类中的const变量要在构造函数初始化列表中初始化；static const变量可以在类内或类外初始化；static全局或局部变量没有显示初始化会被编译器自动赋初值。</strong></li>
<li>sizeof与strlen：sizeof是运算符（参数可以是类型或者函数名），对于静态分配的数组返回编译期决定的大小；strlen是函数（char*作为参数），数到’\0’为止</li>
<li>malloc和new：malloc是库函数，动态分配内存，范围void<em>，无类型信息，free释放；new是运算符，根据编译期类型信息调用相应的构造函数，delete释放；<br><em>*野指针：动态分配的内存空间被释放后指针如果不赋值为NULL就会造成不可预知的程序结果，该指针为野指针</em></em></li>
<li>explicit：修饰只有一个参数的类构造函数（或者后面参数都有默认值），调用该构造函数必须显示转换</li>
</ol>
<p><a href="http://www.cnblogs.com/ymy124/p/3632634.html" target="_blank" rel="external">C++ explicit关键字详解</a></p>
<ol>
<li>volatile: volatile定义的变量在使用处禁止编译器的优化，每次使用都要从对应的内存地址读取</li>
</ol>
<p><a href="http://blog.csdn.net/whatday/article/details/52511071" target="_blank" rel="external">C/C++中volatile关键字详解</a></p>
<ol>
<li>struct和class：默认权限不同。struct是public但是class中是private；struct不能定义函数；C++中的struct对C进行了扩充，可以有构造函数，也可以加权限修饰符；C++中class默认private继承，struct默认public继承</li>
<li>restrict：如果用const变量的地址赋值非const指针，const的作用就会失去，如果用restrict修饰指针，该指针指向的内存空间只能通过该指针进行访问。</li>
</ol>
<h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><ol>
<li>虚函数：拥有虚函数的类对象都有一个指向其虚函数表的指针；如果是多继承（父类都定义有虚函数），对象中会有对个虚函数表指针<br><a href="http://blog.csdn.net/qq_26437925/article/details/63251184" target="_blank" rel="external">C语言实现多态</a></li>
</ol>
<h2 id="STL总结"><a href="#STL总结" class="headerlink" title="STL总结"></a>STL总结</h2><p>STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。</p>
<p>序列容器：容器里的元素是有位置先后的<br>(a)array：静态连续，大小不变，支持随机访问，迭代器；<br>(b)vector：动态连续，大小可变，支持随机存取；<br>(c)deque：双头队列，内存不连续；<br>(d)forward_list：单项列表，不支持随机存取，增删元素指向其他元素的迭代器不失效；<br>(e)list：双向列表，增删元素指向其他元素的迭代器不失效；</p>
<p>关联容器：关联容器里的值,都按照某种规则(元素值的大小)进行了排序，可遍历<br>(a)set: 集合，关键字唯一，O(logn)，迭代器顺序输出<br>(b)multiset：有重复元素，C++11新增<br>(c)map：红黑树，可用迭代器按key的顺序输出<br>(d)multimap：key可重复</p>
<p>无序关联容器：容器中的值都是不进行排序的，C++11中新增<br>(a)unordered_set：无序集合，hash实现，等值元素唯一，搜索插入删除时间常量<br>(b)unordered_map：无序映射，关键字等值元素唯一，搜索插入删除时间常量<br>(c)unordered_multiset：无序可重复，复杂度常量<br>(d)unordered_multimap：无序可重复，复杂度常量</p>
<p>容器适配器：为序列容器提供了不一样的接口<br>(a)stack：LIFO<br>(b)queue：FIFO<br>(d)priority_queue：底层用vector和heap函数实现，第一个元素总是最大(小)，不能遍历只能访问第一个值</p>
<h2 id="编译链接和程序运行内存模型"><a href="#编译链接和程序运行内存模型" class="headerlink" title="编译链接和程序运行内存模型"></a>编译链接和程序运行内存模型</h2><h3 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h3><p>预处理（宏的替换，删除注释，递归展开#include，处理#ifdef）-&gt;编译（词法分析，语法分析，语义分析，优化，目标代码生成）-&gt;生成目标文件（ELF）-&gt;链接</p>
<img src="/2017/08/18/Interview-Common-Questions/elf.png" alt="ELF结构" title="ELF结构">
<h3 id="静态函数库，共享函数库，动态函数库"><a href="#静态函数库，共享函数库，动态函数库" class="headerlink" title="静态函数库，共享函数库，动态函数库"></a>静态函数库，共享函数库，动态函数库</h3><ol>
<li>静态函数库：程序执行前就加入到目标程序当中去了</li>
<li>共享函数库：则是在程序启动的时候加载到程序中，它可以被不同的程序共享；指定LD_LIBRARY_PATH搜寻共享函数库</li>
<li>动态函数库：动态加载函数库则可以在程序运行的任何时候动态的加载</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char *argv)&#123;  </div><div class="line">        void *handle;  </div><div class="line">        char *error;  </div><div class="line">          </div><div class="line">        double (*cosine )(double);  </div><div class="line">        handle = dlopen(&quot;/lib/libm.so.6&quot;, RTLD_LAZY);  </div><div class="line">        if(!handle)&#123;  </div><div class="line">            fputs(dlerror(), stderr);  </div><div class="line">             exit(1);  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        cosine = dlsym(handle, &quot;cos&quot;);  </div><div class="line">        if((error = dlerror()) != NULL)&#123;  </div><div class="line">            fputs(error, stderr);  </div><div class="line">            exit(1);  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        printf(&quot;%f&quot;, (*cosine)(2, 0));  </div><div class="line">          </div><div class="line">        dlclose(handle);  </div><div class="line">          </div><div class="line">        return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="C-程序内存模型"><a href="#C-程序内存模型" class="headerlink" title="C++程序内存模型"></a>C++程序内存模型</h3><p>堆，（共享库.so的存储映射区），栈，全局/静态存储区（读写段，.bss放未初始化，.data放初始化），只读段（.init，.text代码段，.rodata常量），内核虚拟存储器（对用户代码不可见，系统调用）</p>
<p><a href="http://www.cnblogs.com/Stultz-Lee/p/6751522.html" target="_blank" rel="external">C和C++内存模型</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="C-11新增的特性"><a href="#C-11新增的特性" class="headerlink" title="C++11新增的特性"></a>C++11新增的特性</h3><p>常用：auto自动类型推导，decltype推导类型，nullptr(NULL可以转成0，nullptr不可以)，序列for循环（有点像python），lambda表达式，更多初始化方法</p>
<p><a href="http://www.cnblogs.com/pzhfei/archive/2013/03/02/CPP_new_feature.html" target="_blank" rel="external">30分钟了解C++11新特性</a></p>
<p><a href="http://www.cnblogs.com/pzhfei/archive/2013/03/02/CPP_new_feature.html#section_3.1" target="_blank" rel="external">C++11新特性</a></p>
<h3 id="C-常见的设计模式"><a href="#C-常见的设计模式" class="headerlink" title="C++常见的设计模式"></a>C++常见的设计模式</h3><ol>
<li><p>单例模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">public:</div><div class="line">	static Singleton* s = NULL;</div><div class="line">	Singleton* getSingleton()&#123;</div><div class="line">		if(s == NULL)&#123;</div><div class="line">			s = new Singleton();</div><div class="line">		&#125;</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">private:</div><div class="line">	Singleton();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>工厂模式：产品类+工厂类+主类</p>
</li>
<li>策略模式：策略接口实现不同策略，主类调用</li>
<li>适配器模式：将外部类转化成内部类的格式</li>
</ol>
<p><a href="http://www.cnblogs.com/wanggary/category/294620.html" target="_blank" rel="external">C++设计模式</a></p>
<h3 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h3><p>智能指针构造函数为explicit，要用指向对象的指针显示构造<br>scoped_ptr:指向的对象在作用域外会自动析构<br>shared_ptr：引用计数为0时自动析构<br>weak_ptr：解决shared_ptr中引用关系成环，不保证内存有效，使用前检查null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class shared                                    //一个拥有shared_ptr的类    </div><div class="line">&#123;    </div><div class="line">private:        </div><div class="line">    shared_ptr&lt;int&gt; p;                          //shared_ptr成员变量    </div><div class="line">public:        </div><div class="line">    shared(shared_ptr&lt;int&gt; p_):p(p_)&#123;&#125;          //构造函数初始化shared_ptr        </div><div class="line">    void print()                                //输出shared_ptr的引用计数和指向的值        </div><div class="line">    &#123;          cout &lt;&lt; &quot;count:&quot; &lt;&lt; p.use_count()                </div><div class="line">    &lt;&lt; &quot;v =&quot; &lt;&lt;*p &lt;&lt; endl;        </div><div class="line">    &#125;    </div><div class="line">&#125;;    </div><div class="line">void print_func(shared_ptr&lt;int&gt; p)                //使用shared_ptr作为函数参数    </div><div class="line">&#123;         </div><div class="line">    //同样输出shared_ptr的引用计数和指向的值        </div><div class="line">    cout &lt;&lt; &quot;count:&quot; &lt;&lt; p.use_count()            </div><div class="line">        &lt;&lt; &quot; v=&quot; &lt;&lt;*p &lt;&lt; endl;  &#125;    </div><div class="line">int main()    </div><div class="line">&#123;        </div><div class="line">    shared_ptr&lt;int&gt; p(new int(100));        </div><div class="line">    shared s1(p), s2(p);                        //构造两个自定义类         </div><div class="line">    s1.print();        </div><div class="line">    s2.print();         </div><div class="line">    *p = 20;                                    //修改shared_ptr所指的值        </div><div class="line">    print_func(p);                              //输出的计数为4，函数传参多引用了一次！！！</div><div class="line">    s1.print();    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://blog.csdn.net/worldwindjp/article/details/18843087" target="_blank" rel="external">如何理解智能指针</a></p>
<h1 id="Java面试题（outline）"><a href="#Java面试题（outline）" class="headerlink" title="Java面试题（outline）"></a>Java面试题（outline）</h1><h2 id="Java内存区域与GC机制"><a href="#Java内存区域与GC机制" class="headerlink" title="Java内存区域与GC机制"></a>Java内存区域与GC机制</h2><p>方法区：用于存储已加载的类型信息，有静态区，共享数据区；线程共享<br>堆区：较大，用于存放new产生的类对象<br>栈：存放基础数据类型，对象的引用，函数调用形参<br>本地方法栈<br>GC机制：年轻代（停止-复制）——有eden区和两个survive区，每一次清理将Eden和一个survive中的存活对象复制到另一个survive区；年老代（标记-整理）——大型对象可能直接到年老代，年轻代中存活已久的也会到年老代；永久代（方法区）——常量和类型信息</p>
<p><a href="http://www.cnblogs.com/zhguang/p/3257367.html#introduction" target="_blank" rel="external">Java 内存区域和GC机制</a></p>
<h2 id="面向对象相关概念"><a href="#面向对象相关概念" class="headerlink" title="面向对象相关概念"></a>面向对象相关概念</h2><p>向上转型：不能调用子类中有的父类中没有的；除了private类型其他成员都转成父类中的<br>向下转型：直接父类向下转型编译时通过，运行时出错；<br>重载：类中方法同名不同参不同返回类型<br>重写：多态；子类重写父类同名方法；private方法和static方法没有多态；所有private方法默认是final的<br>接口：域隐式为static final，方法默认public；可以实现多继承<br>内部类：定义放在另一个类的内部，能访问外围类的所有成员<br>匿名类：返回值返回时定义类型<br>嵌套类：static内部类，内部类不依赖于外部类存在<br>泛型：&lt;? extends T&gt;包括T在内的任何T的子类；&lt;? super T&gt;包括T在内的任何T的父类；</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>==：基本类型比较数值，对象比较地址<br>equals：不能用于数据类型，为重写比较对象类型，一般Java类都会重写equals<br>hashcode：对地址进行hash，但是会有冲突<br>final：(a)final数据：基本类型值不变，一般类型表示指针不知指向别的对象但不保证对象的值不改变，final数组也可修改；final形参表示不能在函数体中改变引用指向的对象（b)final方法不能被覆盖，private方法在向上转型后不能被调用(c)final类不能被继承<br>instanceof：判断是否是继承关系<br>static：成员函数不能用this指针；static不修饰构造函数，函数参数；static修饰字段加载时初始化；static方法和成员属于整个类<br>volatile：保证变量在每次使用时从主存中获得最新的值，并不保证同步</p>
<h2 id="持有对象"><a href="#持有对象" class="headerlink" title="持有对象"></a>持有对象</h2><p>Collection(List, Set, Queue)的基类<br>Collections提供一些API<br>List：LinkedList,ArrayList<br>Set：HashSet,TreeSet<br>Queue：Queue,PriorityQueue<br>Map：HashMap,LinkedHashMap,TreeMap<br>同步容器：vector，stack，HashTable，成员函数synchronize实现</p>
<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><ol>
<li>implements Runable；重写run()，生成Runnable对象传入Thread Constructor，调用.start（）</li>
<li>extends Thread；重写run()，直接生成Thread对象</li>
<li>synchronized方法调用时，改对象的其他synchronized方法调用要等其结束</li>
<li>synchronized static可以控制类范围内对static数据的并发访问</li>
<li>ThreadLocal为每一线程维护一组本地变量</li>
<li>Thread类sleep(),yield();Object类wait(),notify(),notifyAll()</li>
</ol>
<p><a href="http://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="external">Java多线程详解</a></p>
<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>每个类被编译后都会产生一个Class对象，在.class文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; obj = null;</div><div class="line">obj = Class.forName(&quot;XXX&quot;);</div><div class="line">obj = new ClassName().getClass();</div><div class="line">obj = ClassName.class;</div><div class="line">//直接通过无参构造函数构造</div><div class="line">obj = (ClassName)classObj.newInstance();</div><div class="line">//获取类型信息</div><div class="line">Construnctor&lt;?&gt; cons[] = classObj.getConstructors();</div><div class="line">//getInterfaces(),SuperClass(),DeclaredFields()....</div><div class="line">Method m = clssObj.getMethod(&quot;XXX&quot;);</div></pre></td></tr></table></figure></p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>equals(),finalize(),getClass(),hashCode(),toString(),notify(),notifyAll(),wait();</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>元注解：@target,@Retention,@Documented,@Inherited<br>注解解释器：用反射getAnnotations()；</p>
<p><a href="http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html" target="_blank" rel="external">深入理解Java注解</a></p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>@Component 把普通类实例化到容器中，相当于配置bean文件<br>@Autowired 自动装配<br>@Controller 控制器<br>@Mapper DAO层类定义<br>@Service<br>@Aspect 切面编程（@Before @After）<br>使用Bean的注解：@Autowired，@Resource<br>注册Bean的注解：@Component，@Repository，@Controller，@Service，@Configuration</p>
<h1 id="操作系统，体系结构与数据库"><a href="#操作系统，体系结构与数据库" class="headerlink" title="操作系统，体系结构与数据库"></a>操作系统，体系结构与数据库</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>五大功能：进/线程管理，存储管理，文件管理，设备管理，用户接口<br>四大特征：并发，共享，虚拟，随机<br>用户态-&gt;内核态：中断（外设），异常（CPU内部），陷入（系统调用）<br>内核态-&gt;用户态：恢复程序状态字（PSW）<br>中断：中断向量号-&gt;（根据IDTR:中断向量表寄存器）-&gt;在中断向量表中找到中断描述符-&gt;（根据GDTR：全局描述表）-&gt;找到段描述符-&gt;中断描述符还有段基址便宜，找到相应的中断处理程序<br>系统调用：陷入（访管）指令-&gt;系统调用号-&gt;系统调用表（用户态到内核态传参可以通过(a)陷入指令自带参数(b)通用寄存器(c)内存堆栈）</p>
<h2 id="进程、线程CPU调度"><a href="#进程、线程CPU调度" class="headerlink" title="进程、线程CPU调度"></a>进程、线程CPU调度</h2><ol>
<li>进程：具有独立功能的程序关于某个数据集合上的一次运行活动<br>PCB：进程描述信息（PID，进程名，user ID），进程控制信息（状态，优先级，磁盘地址），进程使用情况（虚拟空间地址，文件列表），CPU现场信息（PC，PSW，通用寄存器，SP，页表指针）<br>进程的三种状态：运行，就绪，等待</li>
<li>线程：线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，每个线程都有自己的堆栈。<br>用户级线程：线程切换不需要进内核（Pthread）；优点：快，程序可以指定调度算法，操作系统兼容；缺点：不适用多处理器，系统调用使得线程阻塞进程；<br>核心级线程：内核管理线程并提供API（Windows）</li>
<li>同步机制<br>临界资源：系统中某些资源一次只允许一个进程使用<br>临界区：对临界资源进行操作的代码<br>Linux中的锁：(a)mutex互斥量：调用者设置锁并阻塞；(b)自旋锁：忙等，不断请求自旋锁（适用于多处理器）；(c)条件变量pthread<em>con</em>，用于信号传递；(d)读写锁：写加锁状态时所有试图加锁的线程都会被阻塞；读加锁状态时读加锁线程可以访问写加锁线程阻塞；读加锁状态时有写加锁，读写锁通常会阻塞后续的读加锁请求以防长期被读加锁占据</li>
<li>IPC方式（send/receive原语，内存共享，管道…）</li>
<li>死锁：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。<br>死锁条件：互斥，不可抢占，占有并等待，环形等待<br>银行家算法：n个进程，m种资源；剩余资源Available[n][m]，分配Allocation[n][m]，需求Need[n][m]，请求Request[n][m]</li>
</ol>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件：一组带标识的、在逻辑上有完整意义的信息项的序列<br>磁盘空间的管理：位图法，空闲块表，空闲块链表<br>FCB：文件名，文件号，文件大小， 文件地址， 创建时间，最后修改时间，最后访问时间， 保护，口令，创建者，当前拥有者，文件类型，共享计数，各种标志(只读、隐藏、系统、归档、 ASCII/二进制、顺序/随机访问、临时文件、锁)<br>文件基本操作：create,delete,open,close,read,write,append,seek,get/set Attribute, rename<br>文件目录：统一管理文件的元数据；目录文件：将文件目录以文件形式存在磁盘上；目录项：构成文件目录的基本单位，可以是FCB<br>磁盘文件组织：连续磁盘块文件（随机存取寻道次数少）；链接结构（文件的前一块指向后一块）；FAT（文件分配表，Windows FAT32支持长文件和Unicode）表项的值有三种0，下一块块号，-1；索引结构（为每个文件存一个所以块，顺序纪录文件的物理块号，FCB中存索引块位置，可能需要多级索引表）<br><img src="/2017/08/18/Interview-Common-Questions/disk.png" alt="磁盘文件组织" title="磁盘文件组织"><br>内存文件组织：整个系统存一张已打开的FCB表（FCB=目录项+i节点；目录项=文件名+i节点号；i节点描述文件相关信息），每个进程有一张用户打开文件表（FD，FCB）</p>
<h2 id="IO系统"><a href="#IO系统" class="headerlink" title="IO系统"></a>IO系统</h2><p>阻塞I/O，非阻塞I/O，I/O多路复用，同步和异步I/O的概念以及select，poll，epoll<br><img src="/2017/08/18/Interview-Common-Questions/io.png" alt="IO方式总结" title="IO方式总结"></p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></p>
<h2 id="数据库ACID"><a href="#数据库ACID" class="headerlink" title="数据库ACID"></a>数据库ACID</h2><p>Atomicity：原子性，事务是不可再分隔的工作单位，事务中的操作要么都发生要么都不发生<br>Consistency：一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上<br>Isolation：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。<br>Duarability：持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。</p>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>B+树叶子节点存索引指针，内部节点用来索引<br><strong>聚集索引：指索引项的排序方式和表中数据记录排序方式一致的索引</strong><br>聚集索引的使用场合为：<br>　　a.查询命令的回传结果是以该字段为排序依据的；<br>　　b.查询的结果返回一个区间的值；<br>　　c.查询的结果返回某值相同的大量结果集。<br>聚集索引会降低 insert，和update操作的性能，所以，是否使用聚集索引要全面衡量。<br><strong>非聚集索引： 索引顺序与物理存储顺序不同</strong><br>非聚集索引的使用场合为：<br>　　a.查询所获数据量较少时；<br>　　b.某字段中的数据的唯一性比较高时；<br>非聚集索引必须是稠密索引<br>聚簇索引：并不是一种单独的索引类型，而是一种数据存储方式。术语“聚簇”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行放在两个不同的地方，所以一个表只能有一个聚簇索引。<br>聚族索引的优点：可以把相关数据保存在一起。就好像在操场上战队，一个院系一个院系的站在一起，这样要找到一个人，就先找到他的院系，然后在他的院系里找到他就行了，而不是把学校里的所有人都遍历一遍。数据访问更快。聚族索引将索引和数据保存在同一个B-Tree中，因此从聚族索引中获取数据通常比在非聚族索引中查找更快。<br>稠密索引：每个索引键值都对应有一个索引项<br>稀疏索引：相对于稠密索引，稀疏索引只为某些搜索码值建立索引记录；在搜索时，找到其最大的搜索码值小于或等于所查找记录的搜索码值的索引项，然后从该记录开始向后顺序查询直到找到为止。<br><a href="http://m.blog.csdn.net/DoUUnderstand/article/details/70215061" target="_blank" rel="external">数据库索引</a></p>
<h2 id="体系结构相关概念"><a href="#体系结构相关概念" class="headerlink" title="体系结构相关概念"></a>体系结构相关概念</h2><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>Cache address mapping：Directly_mapped cache(1 line in each set)，Set associate cache(different tags in a same set)， Fully assiciate cache(only one set)<br>Cache category：i-cache/d-cache，pyhsically addressed cache/virtually addressed cache, bloking cache/non-blocking cache, L1/L2/L3 cache<br>Cache Read: Set selection-&gt;line matching-&gt;word extraction<br>Cache Write:(a)Cache hit:write through/write back;(b)Cache miss:write alocate/write no-allocate</p>
<h3 id="Vitual-Memory"><a href="#Vitual-Memory" class="headerlink" title="Vitual Memory"></a>Vitual Memory</h3><p>概念：MMU(memory management unit)，页表(页表项映射物理存储器，每个进程都有一个page table entry)，Cache可以同时缓存页表项和数据，TLB(translation lookaside table)是MMU中关于PTE的缓存<br>进程的虚拟存储：<br><img src="/2017/08/18/Interview-Common-Questions/pvm.png" alt="一个Linux进程的虚拟地址空间" title="一个Linux进程的虚拟地址空间"></p>
<p>物理存储器中：私有对象，共享对象，写时拷贝</p>
<h2 id="常用Shell命令总结"><a href="#常用Shell命令总结" class="headerlink" title="常用Shell命令总结"></a>常用Shell命令总结</h2><p><strong>awk</strong><br>-F指定分隔符<br>awk [-F  field-separator]  ‘{pattern + action}’  input-file(s)<br>pattern：用//括起来<br>用printf比print更易读<br>awk内置变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ARGC               命令行参数个数</div><div class="line">ARGV               命令行参数排列</div><div class="line">ENVIRON            支持队列中系统环境变量的使用</div><div class="line">FILENAME           awk浏览的文件名</div><div class="line">FNR                浏览文件的记录数！！！</div><div class="line">FS                 设置输入域分隔符，等价于命令行 -F选项</div><div class="line">NF                 浏览记录（一行）的域的个数！！！</div><div class="line">NR                 已读的记录数！！！</div><div class="line">OFS                输出域分隔符</div><div class="line">ORS                输出记录分隔符</div><div class="line">RS                 控制记录分隔符</div></pre></td></tr></table></figure></p>
<p>awk编程：<br>action:’BEGIN{}{}END{}’<br>if statement：与C语言相同（还有while,do/while,for,break,continue）<br>数组：key-value</p>
<p><strong>uniq</strong><br>过滤重复文件，不加任何参数只比较相邻行，只显示连续重复的行一次<br>–c 显示输出中本行连续输出的次数。它可取代-u和-d选项。<br>–d 只显示重复行。<br>–u 只显示文件中不重复的各行。<br>–n 前n个字段与每个字段前的空白一起被忽略。一个字段是一个非空格、非制表符的字符串，彼此由制表符和空格隔开(字段从0开始编号)。<br>+n 前n个字符被忽略，之前的字符被跳过(字符从0开始编号)。<br>–fn 与-n相同，这里n是字段数。<br>–sn 与+n相同，这里n是字符数。</p>
<p><strong>sort</strong><br>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]<br>常见选项：<br>-b 忽略开头空格<br>-n 依照数值大小排序<br>-r 以相反顺序来排序<br>-t&lt;分隔字符&gt; 指定排序时所用栏位的分隔字符<br>+&lt;起始栏位&gt;-&lt;结束栏位&gt;<br>-k 1.2 1.3表示比较第一项第二字符到第一项第三个字符</p>
<p><strong>wc</strong><br>wc [options] file(s)：输出行数，单词数，字节数，文件名<br>-c 统计字节数<br>-l 统计行数<br>-m 统计字符数<br>-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络五层模型"><a href="#网络五层模型" class="headerlink" title="网络五层模型"></a>网络五层模型</h2><p>物理层：中继器，集线器<br>数据链路层：网桥，交换机<br>网络层：路由器，IP，ICNP，ARP，RARP<br>传输层：TCP，UDP<br>应用层：FTP，Telnet，DNS，SMTP，POP3，HTTP<br>TCP对应的协议：FTP，Telnet，POP3，HTTP，SMTP<br>UDP对应的协议：DNS，SNMP，TFTP</p>
<h2 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a>TCP三次握手与四次挥手</h2><img src="/2017/08/18/Interview-Common-Questions/tcp.png" alt="TCP三次握手与四次挥手全过程" title="TCP三次握手与四次挥手全过程">
<h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><p>(1)TCP面向连接，UDP无连接<br>(2)系统资源开销不一样<br>(3)TCP面向字节流，UDP面向数据报<br>(4)TCP有准确性控制，保证数据顺序，可以重发；UDP会丢包，不保证顺序，不重发<br>TCP server：创建socket-&gt;setsockpt设置属性-&gt;bind绑定ip-&gt;listen()监听-&gt;accept()接受连接-&gt;send/recv或者read/write-&gt;关闭连接-&gt;关闭监听<br>TCP client：创建socket-&gt;setsockpt设置属性-&gt;bind绑定ip-&gt;recvfrom()-&gt;关闭连接<br>UDP server：创建socket-&gt;setsockpt设置属性-&gt;bind绑定ip-&gt;sendto()-&gt;关闭<br>UDP client：创建socket-&gt;setsockpt设置属性-&gt;bind绑定ip-&gt;recvfrom()-&gt;关闭<br><strong>TCP拥塞控制</strong><br>慢启动（指数增长）-&gt;逐步增长加倍递减（超过阈值后）-&gt;响应超时<br>CongWin：控制TCP发送速率的窗口<br>RTT：TCP发送到收到ACK的时间<br>发送速率=CongWin/RTT<br>TCP拥塞控制算法：<br>(1)拥塞窗口低于Threshold时，慢启动，指数增长。<br>(2)拥塞窗口大于Threshold时，线性增长。<br>(3)发生收到3次重复ACK的丢包事件，Threshold设为当前拥塞窗口的一半，并将拥塞窗口设为Threshold，重传ACK对应包。<br>(4)发生“超时”丢包事件时，Threshold设为当前拥塞窗口的一半，并把拥塞窗口设为最小单位重新开始慢启动。<br><img src="/2017/08/18/Interview-Common-Questions/tcp_control.png" alt="TCP拥塞控制算法" title="TCP拥塞控制算法"></p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>GET：请求读取由URL所标志的信息。<br>POST：给服务器添加信息（如注释）。<br>PUT：在给定的URL下存储一个文档。<br>DELETE：删除给定的URL所标志的资源。<br>GET与POST区别：<br>(1)Get是从服务器上获取数据，Post是向服务器传送数据。<br>(2)Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。<br>(3)Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。<br>(4)根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>
<h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p>A类地址：以0开头，第一个字节范围：0~127；<br>B类地址：以10开头，第一个字节范围：128~191；<br>C类地址：以110开头，第一个字节范围：192~223；<br>D类地址：以1110开头，第一个字节范围为224~239；（组播地址）</p>
<p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255<br>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255<br>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p>
<p>0.0.0.0：寻找自己IP的地址</p>
<p>127.0.0.0~8：本机地址</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://leetcode.com/problems/regular-expression-matching/description/" target="_blank" rel="external">regular expression matching</a><br><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="external">Letter Combinations of a Phone Number</a><br><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="external">Remove Nth Node From End of List</a><br><a href="https://leetcode.com/problems/divide-two-integers/description/" target="_blank" rel="external">Devide Two Integers</a><br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/" target="_blank" rel="external">Substring with Concatenation of All Words</a><br><a href="https://leetcode.com/problems/longest-valid-parentheses/description/" target="_blank" rel="external">Longest Valid Parentheses</a><br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="external">Search for a Range</a><br><a href="https://leetcode.com/problems/sudoku-solver/description/" target="_blank" rel="external">Sodoku Solver</a><br><a href="https://leetcode.com/problems/trapping-rain-water/description/" target="_blank" rel="external">Trapping Rain Water</a><br><a href="https://leetcode.com/problems/first-missing-positive/description/" target="_blank" rel="external">First Missing Positive</a><br><a href="https://leetcode.com/problems/wildcard-matching/description/" target="_blank" rel="external">Wildcard Matching</a><br><a href="https://leetcode.com/problems/jump-game-ii/description/" target="_blank" rel="external">Jump Game II</a><br><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="external">N-Queens</a><br><a href="https://leetcode.com/problems/group-anagrams/description/" target="_blank" rel="external">Group Anagrams</a><br><a href="https://leetcode.com/problems/insert-interval/description/" target="_blank" rel="external">Insert Interval</a><br><a href="https://leetcode.com/problems/valid-number/description/" target="_blank" rel="external">Valid Number</a><br><a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="external">Minimum Window Substring</a><br><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" target="_blank" rel="external">Largest Rectangle in Histogram</a><br><a href="https://leetcode.com/problems/maximal-rectangle/description/" target="_blank" rel="external">Maximal Rectangle</a><br><a href="https://leetcode.com/problems/scramble-string/description/" target="_blank" rel="external">Scramble String</a><br><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/" target="_blank" rel="external">Unique Binary Search Trees II</a><br><a href="https://leetcode.com/problems/interleaving-string/description/" target="_blank" rel="external">Interleaving String</a><br><a href="https://leetcode.com/problems/recover-binary-search-tree/description/" target="_blank" rel="external">Recover Binary Search Tree</a></p>
<h1 id="欢迎交流"><a href="#欢迎交流" class="headerlink" title="欢迎交流"></a>欢迎交流</h1><p>博客中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>
<ul>
<li>邮件(lyubinbinpku#163.com, 把#换成@)</li>
<li>QQ: 1257508426</li>
<li>weibo: <a href="http://weibo.com/lyricistpku" target="_blank" rel="external">@朝花夕拾大伯彬</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[判断平衡二叉树]]></title>
      <url>http://LyricistPKU.github.io/2016/08/27/%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>输入一颗二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树的任意节点的左右子树深度相差不超过1，那么它就是一棵平衡二叉树。例如下图就是一棵平衡二叉树。</p>
<img src="/2016/08/27/判断平衡二叉树/balancedtree.jpg" alt="This is an example image" title="This is an example image">
<a id="more"></a>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="1-一种直观而不高效的解法"><a href="#1-一种直观而不高效的解法" class="headerlink" title="1.一种直观而不高效的解法"></a>1.一种直观而不高效的解法</h3><p>这个问题很容易想到仿照求二叉树深度的方法，如果左右两个子树的深度相差超过1，那么这棵树就不是平衡二叉树。虽然这种解法的代码简单，但是递归中重复计算量太大。这种思路对应的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalancedTree</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">int</span> left = TreeDepth(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> right = TreeDepth(root-&gt;right);</div><div class="line">    <span class="keyword">int</span> diff = left - right;</div><div class="line">    <span class="keyword">if</span>(diff &lt; <span class="number">-1</span> || diff &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (IsBalancedTree(root-&gt;left) &amp;&amp; IsBalancedTree(root-&gt;right));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> left = TreeDepth(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> right = TreeDepth(root-&gt;right);</div><div class="line">    <span class="keyword">return</span> (left &gt; right ? left : right ) + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-用后续遍历来减少重复的递归"><a href="#2-用后续遍历来减少重复的递归" class="headerlink" title="2.用后续遍历来减少重复的递归"></a>2.用后续遍历来减少重复的递归</h3><p>如果我们用<code>后序遍历</code>的方式遍历二叉树的每一个节点，在遍历到一个节点之前我们已经访问过它的左右子节点并记录下了它们的深度，我们就可以判断该树是不是平衡二叉树了！这种思路对应的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalancedTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span>* pdepth)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</div><div class="line">        *pdepth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> left, right;</div><div class="line">    <span class="keyword">if</span>(IsBalancedTree(root-&gt;left, &amp;left) &amp;&amp; </div><div class="line">        IsBalancedTree(root-&gt;left, &amp;left))&#123;</div><div class="line">        <span class="keyword">int</span> diff = left - right;</div><div class="line">        <span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff &gt;= <span class="number">-1</span>)&#123;</div><div class="line">            *pdepth = (left &gt; right ? left : right) + <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Solution</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> IsBalancedTree(root, &amp;depth);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ol>
<li><code>功能测试</code>（平衡二叉树，非平衡二叉树，二叉树所有的节点都没有左右子树）。</li>
<li><code>特殊测试用例</code>（二叉树中只有一个节点，二叉树根节点为NULL）</li>
</ol>
<h2 id="欢迎交流"><a href="#欢迎交流" class="headerlink" title="欢迎交流"></a>欢迎交流</h2><p>博客中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>
<ul>
<li>邮件(lyubinbinpku#163.com, 把#换成@)</li>
<li>QQ: 1257508426</li>
<li>weibo: <a href="http://weibo.com/lyricistpku" target="_blank" rel="external">@Lyricist勤Coding</a></li>
<li>github: <a href="https://github.com/LyricistPKU" target="_blank" rel="external">@LyricistPKU</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://LyricistPKU.github.io/2016/08/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
