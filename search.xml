<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Interview Common Questions]]></title>
      <url>http://LyricistPKU.github.io/2017/08/18/Interview-Common-Questions/</url>
      <content type="html"><![CDATA[<p>Anything about the interview preparing. Still Updating…<br><a id="more"></a></p>
<h1 id="C-面试题"><a href="#C-面试题" class="headerlink" title="C++面试题"></a>C++面试题</h1><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h3><p>变量的定义：为变量分配存储空间（还可以有初始值），定义只能一次<br>变量的声明：向编译器表明变量的类型和名字，声明可以多次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extern int i;	//变量声明未定义</div><div class="line">int i;	//变量声明且定义，未初始化，对于全局变量编译器会赋初值，局部变量未初始化会有意想不到的结果</div><div class="line">//static变量不论是全局还是局部都会有初值</div><div class="line">void fun();		//函数声明</div><div class="line">void fun()&#123;&#125;	//函数定义</div><div class="line">//模板函数声明和定义必须同时在.h文件当中，函数被使用时编译器需要在编译阶段进行模板类型检查而不是在链接阶段找到函数的定义</div></pre></td></tr></table></figure></p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ol>
<li>模板的特化（如果Equal函数对于float和double类型的执行需要特殊处理，就必须特化这两个类型）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">template &lt;class T&gt;</div><div class="line">class TClass</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     bool Equal(const T&amp; arg, const T&amp; arg1);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;class T&gt;</div><div class="line">bool TClass&lt;T&gt;::Equal(const T&amp; arg, const T&amp; arg1)</div><div class="line">&#123;</div><div class="line">     return (arg == arg1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">     TClass&lt;int&gt; obj;</div><div class="line">     cout&lt;&lt;obj.Equal(2, 2)&lt;&lt;endl;</div><div class="line">     cout&lt;&lt;obj.Equal(2, 4)&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">template &lt;class T&gt;</div><div class="line">class Compare</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     bool IsEqual(const T&amp; arg, const T&amp; arg1);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 已经不具有template的意思了，已经明确为float了</div><div class="line">template &lt;&gt;</div><div class="line">class Compare&lt;float&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     bool IsEqual(const float&amp; arg, const float&amp; arg1);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 已经不具有template的意思了，已经明确为double了</div><div class="line">template &lt;&gt;</div><div class="line">class Compare&lt;double&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     bool IsEqual(const double&amp; arg, const double&amp; arg1);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">template &lt;class T&gt;</div><div class="line">bool Compare&lt;T&gt;::IsEqual(const T&amp; arg, const T&amp; arg1)</div><div class="line">&#123;</div><div class="line">     cout&lt;&lt;&quot;Call Compare&lt;T&gt;::IsEqual&quot;&lt;&lt;endl;</div><div class="line">     return (arg == arg1);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">bool Compare&lt;float&gt;::IsEqual(const float&amp; arg, const float&amp; arg1)</div><div class="line">&#123;</div><div class="line">     cout&lt;&lt;&quot;Call Compare&lt;float&gt;::IsEqual&quot;&lt;&lt;endl;</div><div class="line">     return (abs(arg - arg1) &lt; 10e-3);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">bool Compare&lt;double&gt;::IsEqual(const double&amp; arg, const double&amp; arg1)</div><div class="line">&#123;</div><div class="line">     cout&lt;&lt;&quot;Call Compare&lt;double&gt;::IsEqual&quot;&lt;&lt;endl;</div><div class="line">     return (abs(arg - arg1) &lt; 10e-6);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">     Compare&lt;int&gt; obj;</div><div class="line">     Compare&lt;float&gt; obj1;</div><div class="line">     Compare&lt;double&gt; obj2;</div><div class="line">     cout&lt;&lt;obj.IsEqual(2, 2)&lt;&lt;endl;</div><div class="line">     cout&lt;&lt;obj1.IsEqual(2.003, 2.002)&lt;&lt;endl;</div><div class="line">     cout&lt;&lt;obj2.IsEqual(3.000002, 3.0000021)&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>模板的偏特化（特化的模板其实已经不算是模板了，偏特化可以针对不同类型定义各自模板）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 一般化设计</div><div class="line">template &lt;class T, class T1&gt;</div><div class="line">class TestClass</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     TestClass()</div><div class="line">     &#123;</div><div class="line">          cout&lt;&lt;&quot;T, T1&quot;&lt;&lt;endl;</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 针对普通指针的偏特化设计</div><div class="line">template &lt;class T, class T1&gt;</div><div class="line">class TestClass&lt;T*, T1*&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     TestClass()</div><div class="line">     &#123;</div><div class="line">          cout&lt;&lt;&quot;T*, T1*&quot;&lt;&lt;endl;</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 针对const指针的偏特化设计</div><div class="line">template &lt;class T, class T1&gt;</div><div class="line">class TestClass&lt;const T*, T1*&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">     TestClass()</div><div class="line">     &#123;</div><div class="line">          cout&lt;&lt;&quot;const T*, T1*&quot;&lt;&lt;endl;</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">     TestClass&lt;int, char&gt; obj;</div><div class="line">     TestClass&lt;int *, char *&gt; obj1;</div><div class="line">     TestClass&lt;const int *, char *&gt; obj2;</div><div class="line"> </div><div class="line">     return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="C-常见关键字"><a href="#C-常见关键字" class="headerlink" title="C++常见关键字"></a>C++常见关键字</h3><ol>
<li>inline：把函数定义放在符号表中，调用时可以直接替换（注意：inline放在函数声明前无用，必须放在函数定义前）；类中定义的函数编译器在调用处可以自动执行inline的功能，类外定义的（类）函数使用inline发挥该功能</li>
<li><p>typedef与#define：#define定义的宏在编译预处理时被简单替换，不做正确性检查，编译已展开的源程序时报错；typedef给类型定义别名，编译时检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef int* ptr;</div><div class="line">const ptr p;	//p不可更改，但是p指向的内容可以</div><div class="line">#define PTR int*</div><div class="line">const PTR p;	//p可以更改，但是p指向的内容不可以</div></pre></td></tr></table></figure>
</li>
<li><p>static：(a)类外static：函数内static变量只分配一次内存；模块内static变量之内被模块内函数访问（文件作用域）；模块内的static函数只能被模块内的其他函数调用；(b)类内static：类内的static变量对整个类来说只有一份拷贝；类内的static函数为整个类所有，不接受this指针，因此只能访问static成员变量</p>
</li>
<li>const：(a)类外const：可以修饰指针本身或指向对象不可变；函数声明中形参用const，函数内不能改变；对于不想改变的变量可以用const修饰，通常需要初始化；(b)类内const：const成员函数不改变成员变量；返回const值的成员函数，其返回值不能为等式左值；<br><strong>static和const变量初始化问题：类中的static变量初始化要在类外，类名::变量名=值；类中的const变量要在构造函数初始化列表中初始化；static const变量可以在类内或类外初始化；static全局或局部变量没有显示初始化会被编译器自动赋初值。</strong></li>
<li>sizeof与strlen：sizeof是运算符（参数可以是类型或者函数名），对于静态分配的数组返回编译期决定的大小；strlen是函数（char*作为参数），数到’\0’为止</li>
<li>malloc和new：malloc是库函数，动态分配内存，范围void<em>，无类型信息，free释放；new是运算符，根据编译期类型信息调用相应的构造函数，delete释放；<br><em>*野指针：动态分配的内存空间被释放后指针如果不赋值为NULL就会造成不可预知的程序结果，该指针为野指针</em></em></li>
<li>explicit：修饰只有一个参数的类构造函数（或者后面参数都有默认值），调用该构造函数必须显示转换</li>
</ol>
<p><a href="http://www.cnblogs.com/ymy124/p/3632634.html" target="_blank" rel="external">C++ explicit关键字详解</a></p>
<ol>
<li>volatile: volatile定义的变量在使用处禁止编译器的优化，每次使用都要从对应的内存地址读取</li>
</ol>
<p><a href="http://blog.csdn.net/whatday/article/details/52511071" target="_blank" rel="external">C/C++中volatile关键字详解</a></p>
<ol>
<li>struct和class：默认权限不同。struct是public但是class中是private；struct不能定义函数；C++中的struct对C进行了扩充，可以有构造函数，也可以加权限修饰符；C++中class默认private继承，struct默认public继承</li>
<li>restrict：如果用const变量的地址赋值非const指针，const的作用就会失去，如果用restrict修饰指针，该指针指向的内存空间只能通过该指针进行访问。</li>
</ol>
<h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><h2 id="STL总结"><a href="#STL总结" class="headerlink" title="STL总结"></a>STL总结</h2><p>STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。</p>
<p>序列容器：容器里的元素是有位置先后的<br>(a)array：静态连续，大小不变，支持随机访问，迭代器；<br>(b)vector：动态连续，大小可变，支持随机存取；<br>(c)deque：双头队列，内存不连续；<br>(d)forward_list：单项列表，不支持随机存取，增删元素指向其他元素的迭代器不失效；<br>(e)list：双向列表，增删元素指向其他元素的迭代器不失效；</p>
<p>关联容器：关联容器里的值,都按照某种规则(元素值的大小)进行了排序，可遍历<br>(a)set: 集合，关键字唯一，O(logn)，迭代器顺序输出<br>(b)multiset：有重复元素，C++11新增<br>(c)map：红黑树，可用迭代器按key的顺序输出<br>(d)multimap：key可重复</p>
<p>无序关联容器：容器中的值都是不进行排序的，C++11中新增<br>(a)unordered_set：无序集合，hash实现，等值元素唯一，搜索插入删除时间常量<br>(b)unordered_map：无序映射，关键字等值元素唯一，搜索插入删除时间常量<br>(c)unordered_multiset：无序可重复，复杂度常量<br>(d)unordered_multimap：无序可重复，复杂度常量</p>
<p>容器适配器：为序列容器提供了不一样的接口<br>(a)stack：LIFO<br>(b)queue：FIFO<br>(d)priority_queue：底层用vector和heap函数实现，第一个元素总是最大(小)，不能遍历只能访问第一个值</p>
<h2 id="编译链接和程序运行内存模型"><a href="#编译链接和程序运行内存模型" class="headerlink" title="编译链接和程序运行内存模型"></a>编译链接和程序运行内存模型</h2><h3 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h3><p>预处理（宏的替换，删除注释，递归展开#include，处理#ifdef）-&gt;编译（词法分析，语法分析，语义分析，优化，目标代码生成）-&gt;生成目标文件（ELF）-&gt;链接</p>
<img src="/2017/08/18/Interview-Common-Questions/elf.png" alt="ELF结构" title="ELF结构">
<h3 id="静态函数库，共享函数库，动态函数库"><a href="#静态函数库，共享函数库，动态函数库" class="headerlink" title="静态函数库，共享函数库，动态函数库"></a>静态函数库，共享函数库，动态函数库</h3><ol>
<li>静态函数库：程序执行前就加入到目标程序当中去了</li>
<li>共享函数库：则是在程序启动的时候加载到程序中，它可以被不同的程序共享；指定LD_LIBRARY_PATH搜寻共享函数库</li>
<li>动态函数库：动态加载函数库则可以在程序运行的任何时候动态的加载<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char *argv)&#123;  </div><div class="line">        void *handle;  </div><div class="line">        char *error;  </div><div class="line">          </div><div class="line">        double (*cosine )(double);  </div><div class="line">        handle = dlopen(&quot;/lib/libm.so.6&quot;, RTLD_LAZY);  </div><div class="line">        if(!handle)&#123;  </div><div class="line">            fputs(dlerror(), stderr);  </div><div class="line">             exit(1);  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        cosine = dlsym(handle, &quot;cos&quot;);  </div><div class="line">        if((error = dlerror()) != NULL)&#123;  </div><div class="line">            fputs(error, stderr);  </div><div class="line">            exit(1);  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        printf(&quot;%f&quot;, (*cosine)(2, 0));  </div><div class="line">          </div><div class="line">        dlclose(handle);  </div><div class="line">          </div><div class="line">        return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="C-程序内存模型"><a href="#C-程序内存模型" class="headerlink" title="C++程序内存模型"></a>C++程序内存模型</h3><p>堆，（共享库.so的存储映射区），栈，全局/静态存储区（读写段，.bss放未初始化，.data放初始化），只读段（.init，.text代码段，.rodata常量），内核虚拟存储器（对用户代码不可见，系统调用）</p>
<p><a href="http://www.cnblogs.com/Stultz-Lee/p/6751522.html" target="_blank" rel="external">C和C++内存模型</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="C-11新增的特性"><a href="#C-11新增的特性" class="headerlink" title="C++11新增的特性"></a>C++11新增的特性</h3><p>常用：auto自动类型推导，decltype推导类型，nullptr(NULL可以转成0，nullptr不可以)，序列for循环（有点像python），lambda表达式，更多初始化方法</p>
<p><a href="http://www.cnblogs.com/pzhfei/archive/2013/03/02/CPP_new_feature.html" target="_blank" rel="external">30分钟了解C++11新特性</a></p>
<p><a href="http://www.cnblogs.com/pzhfei/archive/2013/03/02/CPP_new_feature.html#section_3.1" target="_blank" rel="external">C++11新特性</a></p>
<h3 id="C-常见的设计模式"><a href="#C-常见的设计模式" class="headerlink" title="C++常见的设计模式"></a>C++常见的设计模式</h3><ol>
<li><p>单例模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">public:</div><div class="line">	static Singleton* s = NULL;</div><div class="line">	Singleton* getSingleton()&#123;</div><div class="line">		if(s == NULL)&#123;</div><div class="line">			s = new Singleton();</div><div class="line">		&#125;</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">private:</div><div class="line">	Singleton();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>工厂模式：产品类+工厂类+主类</p>
</li>
<li>策略模式：策略接口实现不同策略，主类调用</li>
<li>适配器模式：将外部类转化成内部类的格式<br><a href="http://www.cnblogs.com/wanggary/category/294620.html" target="_blank" rel="external">C++设计模式</a></li>
</ol>
<h1 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h1><h1 id="操作系统与体系结构"><a href="#操作系统与体系结构" class="headerlink" title="操作系统与体系结构"></a>操作系统与体系结构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>五大功能：进/线程管理，存储管理，文件管理，设备管理，用户接口<br>四大特征：并发，共享，虚拟，随机<br>用户态-&gt;内核态：中断（外设），异常（CPU内部），陷入（系统调用）<br>内核态-&gt;用户态：恢复程序状态字（PSW）<br>中断：中断向量号-&gt;（根据IDTR:中断向量表寄存器）-&gt;在中断向量表中找到中断描述符-&gt;（根据GDTR：全局描述表）-&gt;找到段描述符-&gt;中断描述符还有段基址便宜，找到相应的中断处理程序<br>系统调用：陷入（访管）指令-&gt;系统调用号-&gt;系统调用表（用户态到内核态传参可以通过(a)陷入指令自带参数(b)通用寄存器(c)内存堆栈）</p>
<h2 id="进程、线程CPU调度"><a href="#进程、线程CPU调度" class="headerlink" title="进程、线程CPU调度"></a>进程、线程CPU调度</h2><ol>
<li>进程：具有独立功能的程序关于某个数据集合上的一次运行活动<br>PCB：进程描述信息（PID，进程名，user ID），进程控制信息（状态，优先级，磁盘地址），进程使用情况（虚拟空间地址，文件列表），CPU现场信息（PC，PSW，通用寄存器，SP，页表指针）<br>进程的三种状态：运行，就绪，等待</li>
<li>线程：线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，每个线程都有自己的堆栈。<br>用户级线程：线程切换不需要进内核（Pthread）；优点：快，程序可以指定调度算法，操作系统兼容；缺点：不适用多处理器，系统调用使得线程阻塞进程；<br>核心级线程：内核管理线程并提供API（Windows）</li>
<li>同步机制<br>临界资源：系统中某些资源一次只允许一个进程使用<br>临界区：对临界资源进行操作的代码<br>Linux中的锁：(a)mutex互斥量：调用者设置锁并阻塞；(b)自旋锁：忙等，不断请求自旋锁（适用于多处理器）；(c)条件变量pthread<em>con</em>，用于信号传递；(d)读写锁：写加锁状态时所有试图加锁的线程都会被阻塞；读加锁状态时读加锁线程可以访问写加锁线程阻塞；读加锁状态时有写加锁，读写锁通常会阻塞后续的读加锁请求以防长期被读加锁占据</li>
<li>IPC方式（send/receive原语，内存共享，管道…）</li>
<li>死锁：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。<br>死锁条件：互斥，不可抢占，占有并等待，环形等待<br>银行家算法：n个进程，m种资源；剩余资源Available[n][m]，分配Allocation[n][m]，需求Need[n][m]，请求Request[n][m]</li>
</ol>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件：一组带标识的、在逻辑上有完整意义的信息项的序列<br>磁盘空间的管理：位图法，空闲块表，空闲块链表<br>FCB：文件名，文件号，文件大小， 文件地址， 创建时间，最后修改时间，最后访问时间， 保护，口令，创建者，当前拥有者，文件类型，共享计数，各种标志(只读、隐藏、系统、归档、 ASCII/二进制、顺序/随机访问、临时文件、锁)<br>文件基本操作：create,delete,open,close,read,write,append,seek,get/set Attribute, rename<br>文件目录：统一管理文件的元数据；目录文件：将文件目录以文件形式存在磁盘上；目录项：构成文件目录的基本单位，可以是FCB<br>磁盘文件组织：连续磁盘块文件（随机存取寻道次数少）；链接结构（文件的前一块指向后一块）；FAT（文件分配表）表项的值有三种0，下一块块号，-1；索引结构（为每个文件存一个所以块，顺序纪录文件的物理块号，FCB中存索引块位置，可能需要多级索引表）<br><img src="/2017/08/18/Interview-Common-Questions/disk.png" alt="磁盘文件组织" title="磁盘文件组织"><br>内存文件组织：整个系统存一张已打开的FCB表（FCB=目录项+i节点；目录项=文件名+i节点号；i节点描述文件相关信息），每个进程有一张用户打开文件表（FD，FCB）</p>
<h2 id="IO系统"><a href="#IO系统" class="headerlink" title="IO系统"></a>IO系统</h2><p>阻塞I/O，非阻塞I/O，I/O多路复用，同步和异步I/O的概念以及select，poll，epoll<br><img src="/2017/08/18/Interview-Common-Questions/io.png" alt="IO方式总结" title="IO方式总结"></p>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></p>
<h2 id="常用Shell命令总结"><a href="#常用Shell命令总结" class="headerlink" title="常用Shell命令总结"></a>常用Shell命令总结</h2><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h1 id="欢迎交流"><a href="#欢迎交流" class="headerlink" title="欢迎交流"></a>欢迎交流</h1><p>博客中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>
<ul>
<li>邮件(lyubinbinpku#163.com, 把#换成@)</li>
<li>QQ: 1257508426</li>
<li>weibo: <a href="http://weibo.com/lyricistpku" target="_blank" rel="external">@Lyricist勤Coding</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[判断平衡二叉树]]></title>
      <url>http://LyricistPKU.github.io/2016/08/27/%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>输入一颗二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树的任意节点的左右子树深度相差不超过1，那么它就是一棵平衡二叉树。例如下图就是一棵平衡二叉树。</p>
<img src="/2016/08/27/判断平衡二叉树/balancedtree.jpg" alt="This is an example image" title="This is an example image">
<a id="more"></a>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="1-一种直观而不高效的解法"><a href="#1-一种直观而不高效的解法" class="headerlink" title="1.一种直观而不高效的解法"></a>1.一种直观而不高效的解法</h3><p>这个问题很容易想到仿照求二叉树深度的方法，如果左右两个子树的深度相差超过1，那么这棵树就不是平衡二叉树。虽然这种解法的代码简单，但是递归中重复计算量太大。这种思路对应的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalancedTree</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">int</span> left = TreeDepth(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> right = TreeDepth(root-&gt;right);</div><div class="line">    <span class="keyword">int</span> diff = left - right;</div><div class="line">    <span class="keyword">if</span>(diff &lt; <span class="number">-1</span> || diff &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (IsBalancedTree(root-&gt;left) &amp;&amp; IsBalancedTree(root-&gt;right));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> left = TreeDepth(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> right = TreeDepth(root-&gt;right);</div><div class="line">    <span class="keyword">return</span> (left &gt; right ? left : right ) + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-用后续遍历来减少重复的递归"><a href="#2-用后续遍历来减少重复的递归" class="headerlink" title="2.用后续遍历来减少重复的递归"></a>2.用后续遍历来减少重复的递归</h3><p>如果我们用<code>后序遍历</code>的方式遍历二叉树的每一个节点，在遍历到一个节点之前我们已经访问过它的左右子节点并记录下了它们的深度，我们就可以判断该树是不是平衡二叉树了！这种思路对应的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalancedTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span>* pdepth)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</div><div class="line">        *pdepth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> left, right;</div><div class="line">    <span class="keyword">if</span>(IsBalancedTree(root-&gt;left, &amp;left) &amp;&amp; </div><div class="line">        IsBalancedTree(root-&gt;left, &amp;left))&#123;</div><div class="line">        <span class="keyword">int</span> diff = left - right;</div><div class="line">        <span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff &gt;= <span class="number">-1</span>)&#123;</div><div class="line">            *pdepth = (left &gt; right ? left : right) + <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Solution</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> IsBalancedTree(root, &amp;depth);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ol>
<li><code>功能测试</code>（平衡二叉树，非平衡二叉树，二叉树所有的节点都没有左右子树）。</li>
<li><code>特殊测试用例</code>（二叉树中只有一个节点，二叉树根节点为NULL）</li>
</ol>
<h2 id="欢迎交流"><a href="#欢迎交流" class="headerlink" title="欢迎交流"></a>欢迎交流</h2><p>博客中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>
<ul>
<li>邮件(lyubinbinpku#163.com, 把#换成@)</li>
<li>QQ: 1257508426</li>
<li>weibo: <a href="http://weibo.com/lyricistpku" target="_blank" rel="external">@Lyricist勤Coding</a></li>
<li>github: <a href="https://github.com/LyricistPKU" target="_blank" rel="external">@LyricistPKU</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://LyricistPKU.github.io/2016/08/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
