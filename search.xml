<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Interview Common Questions]]></title>
      <url>http://LyricistPKU.github.io/2017/08/18/Interview-Common-Questions/</url>
      <content type="html"><![CDATA[<p>Anything about the interview preparing. Still Updating…<br><a id="more"></a></p>
<h1 id="C-面试题"><a href="#C-面试题" class="headerlink" title="C++面试题"></a>C++面试题</h1><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h3><p>变量的定义：为变量分配存储空间（还可以有初始值），定义只能一次<br>变量的声明：向编译器表明变量的类型和名字，声明可以多次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extern int i;	//变量声明未定义</div><div class="line">int i;	//变量声明且定义，未初始化，对于全局变量编译器会赋初值，局部变量未初始化会有意想不到的结果</div><div class="line">//static变量不论是全局还是局部都会有初值</div><div class="line">void fun();		//函数声明</div><div class="line">void fun()&#123;&#125;	//函数定义</div><div class="line">//模板函数声明和定义必须同时在.h文件当中，函数被使用时编译器需要在编译阶段进行模板类型检查而不是在链接阶段找到函数的定义</div></pre></td></tr></table></figure></p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h3 id="C-常见关键字"><a href="#C-常见关键字" class="headerlink" title="C++常见关键字"></a>C++常见关键字</h3><ol>
<li>inline：把函数定义放在符号表中，调用时可以直接替换（注意：inline放在函数声明前无用，必须放在函数定义前）；类中定义的函数编译器在调用处可以自动执行inline的功能，类外定义的（类）函数使用inline发挥该功能</li>
<li><p>typedef与#define：#define定义的宏在编译预处理时被简单替换，不做正确性检查，编译已展开的源程序时报错；typedef给类型定义别名，编译时检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef int* ptr;</div><div class="line">const ptr p;	//p不可更改，但是p指向的内容可以</div><div class="line">#define PTR int*</div><div class="line">const PTR p;	//p可以更改，但是p指向的内容不可以</div></pre></td></tr></table></figure>
</li>
<li><p>static：(a)类外static：函数内static变量只分配一次内存；模块内static变量之内被模块内函数访问（文件作用域）；模块内的static函数只能被模块内的其他函数调用；(b)类内static：类内的static变量对整个类来说只有一份拷贝；类内的static函数为整个类所有，不接受this指针，因此只能访问static成员变量</p>
</li>
<li>const：(a)类外const：可以修饰指针本身或指向对象不可变；函数声明中形参用const，函数内不能改变；对于不想改变的变量可以用const修饰，通常需要初始化；(b)类内const：const成员函数不改变成员变量；返回const值的成员函数，其返回值不能为等式左值；<br><strong>static和const变量初始化问题：类中的static变量初始化要在类外，类名::变量名=值；类中的const变量要在构造函数初始化列表中初始化；static const变量可以在类内或类外初始化；static全局或局部变量没有显示初始化会被编译器自动赋初值。</strong></li>
<li>sizeof与strlen：sizeof是运算符（参数可以是类型或者函数名），对于静态分配的数组返回编译期决定的大小；strlen是函数（char*作为参数），数到’\0’为止</li>
<li>malloc和new：malloc是库函数，动态分配内存，范围void<em>，无类型信息，free释放；new是运算符，根据编译期类型信息调用相应的构造函数，delete释放；<br><em>*野指针：动态分配的内存空间被释放后指针如果不赋值为NULL就会造成不可预知的程序结果，该指针为野指针</em></em></li>
<li>explicit：修饰只有一个参数的类构造函数（或者后面参数都有默认值），调用该构造函数必须显示转换</li>
</ol>
<p><a href="http://www.cnblogs.com/ymy124/p/3632634.html" target="_blank" rel="external">C++ explicit关键字详解</a></p>
<ol>
<li>volatile: volatile定义的变量在使用处禁止编译器的优化，每次使用都要从对应的内存地址读取</li>
</ol>
<p><a href="http://blog.csdn.net/whatday/article/details/52511071" target="_blank" rel="external">C/C++中volatile关键字详解</a></p>
<ol>
<li>struct和class：默认权限不同。struct是public但是class中是private；struct不能定义函数；C++中的struct对C进行了扩充，可以有构造函数，也可以加权限修饰符；C++中class默认private继承，struct默认public继承</li>
<li>restrict：如果用const变量的地址赋值非const指针，const的作用就会失去，如果用restrict修饰指针，该指针指向的内存空间只能通过该指针进行访问。</li>
</ol>
<h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><h2 id="STL总结"><a href="#STL总结" class="headerlink" title="STL总结"></a>STL总结</h2><p>STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。</p>
<p>序列容器：容器里的元素是有位置先后的<br>(a)array：静态连续，大小不变，支持随机访问，迭代器；<br>(b)vector：动态连续，大小可变，支持随机存取；<br>(c)deque：双头队列，内存不连续；<br>(d)forward_list：单项列表，不支持随机存取，增删元素指向其他元素的迭代器不失效；<br>(e)list：双向列表，增删元素指向其他元素的迭代器不失效；</p>
<p>关联容器：关联容器里的值,都按照某种规则(元素值的大小)进行了排序，可遍历<br>(a)set: 集合，关键字唯一，O(logn)，迭代器顺序输出<br>(b)multiset：有重复元素，C++11新增<br>(c)map：红黑树，可用迭代器按key的顺序输出<br>(d)multimap：key可重复</p>
<p>无序关联容器：容器中的值都是不进行排序的，C++11中新增<br>(a)unordered_set：无序集合，hash实现，等值元素唯一，搜索插入删除时间常量<br>(b)unordered_map：无序映射，关键字等值元素唯一，搜索插入删除时间常量<br>(c)unordered_multiset：无序可重复，复杂度常量<br>(d)unordered_multimap：无序可重复，复杂度常量</p>
<p>容器适配器：为序列容器提供了不一样的接口<br>(a)stack：LIFO<br>(b)queue：FIFO<br>(d)priority_queue：底层用vector和heap函数实现，第一个元素总是最大(小)，不能遍历只能访问第一个值</p>
<h2 id="编译链接和程序运行内存模型"><a href="#编译链接和程序运行内存模型" class="headerlink" title="编译链接和程序运行内存模型"></a>编译链接和程序运行内存模型</h2><h3 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h3><p>预处理（宏的替换，删除注释，递归展开#include，处理#ifdef）-&gt;编译（词法分析，语法分析，语义分析，优化，目标代码生成）-&gt;生成目标文件（ELF）-&gt;链接</p>
<img src="/2017/08/18/Interview-Common-Questions/elf.png" alt="ELF结构" title="ELF结构">
<h3 id="C-程序内存模型"><a href="#C-程序内存模型" class="headerlink" title="C++程序内存模型"></a>C++程序内存模型</h3><p>堆，（共享库.so的存储映射区），栈，全局/静态存储区（读写段，.bss放未初始化，.data放初始化），只读段（.init，.text代码段，.rodata常量），内核虚拟存储器（对用户代码不可见，系统调用）</p>
<p><a href="http://www.cnblogs.com/Stultz-Lee/p/6751522.html" target="_blank" rel="external">C和C++内存模型</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="C-11新增的特性"><a href="#C-11新增的特性" class="headerlink" title="C++11新增的特性"></a>C++11新增的特性</h3><p>常用：auto自动类型推导，decltype推导类型，nullptr(NULL可以转成0，nullptr不可以)，序列for循环（有点像python），lambda表达式，更多初始化方法</p>
<p><a href="http://www.cnblogs.com/pzhfei/archive/2013/03/02/CPP_new_feature.html" target="_blank" rel="external">30分钟了解C++11新特性</a></p>
<p><a href="http://www.cnblogs.com/pzhfei/archive/2013/03/02/CPP_new_feature.html#section_3.1" target="_blank" rel="external">C++11新特性</a></p>
<h1 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h1><h1 id="操作系统与体系结构"><a href="#操作系统与体系结构" class="headerlink" title="操作系统与体系结构"></a>操作系统与体系结构</h1><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h1 id="欢迎交流"><a href="#欢迎交流" class="headerlink" title="欢迎交流"></a>欢迎交流</h1><p>博客中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>
<ul>
<li>邮件(lyubinbinpku#163.com, 把#换成@)</li>
<li>QQ: 1257508426</li>
<li>weibo: <a href="http://weibo.com/lyricistpku" target="_blank" rel="external">@Lyricist勤Coding</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[判断平衡二叉树]]></title>
      <url>http://LyricistPKU.github.io/2016/08/27/%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>输入一颗二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树的任意节点的左右子树深度相差不超过1，那么它就是一棵平衡二叉树。例如下图就是一棵平衡二叉树。</p>
<img src="/2016/08/27/判断平衡二叉树/balancedtree.jpg" alt="This is an example image" title="This is an example image">
<a id="more"></a>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="1-一种直观而不高效的解法"><a href="#1-一种直观而不高效的解法" class="headerlink" title="1.一种直观而不高效的解法"></a>1.一种直观而不高效的解法</h3><p>这个问题很容易想到仿照求二叉树深度的方法，如果左右两个子树的深度相差超过1，那么这棵树就不是平衡二叉树。虽然这种解法的代码简单，但是递归中重复计算量太大。这种思路对应的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalancedTree</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">int</span> left = TreeDepth(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> right = TreeDepth(root-&gt;right);</div><div class="line">    <span class="keyword">int</span> diff = left - right;</div><div class="line">    <span class="keyword">if</span>(diff &lt; <span class="number">-1</span> || diff &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (IsBalancedTree(root-&gt;left) &amp;&amp; IsBalancedTree(root-&gt;right));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> left = TreeDepth(root-&gt;left);</div><div class="line">    <span class="keyword">int</span> right = TreeDepth(root-&gt;right);</div><div class="line">    <span class="keyword">return</span> (left &gt; right ? left : right ) + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-用后续遍历来减少重复的递归"><a href="#2-用后续遍历来减少重复的递归" class="headerlink" title="2.用后续遍历来减少重复的递归"></a>2.用后续遍历来减少重复的递归</h3><p>如果我们用<code>后序遍历</code>的方式遍历二叉树的每一个节点，在遍历到一个节点之前我们已经访问过它的左右子节点并记录下了它们的深度，我们就可以判断该树是不是平衡二叉树了！这种思路对应的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalancedTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span>* pdepth)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</div><div class="line">        *pdepth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> left, right;</div><div class="line">    <span class="keyword">if</span>(IsBalancedTree(root-&gt;left, &amp;left) &amp;&amp; </div><div class="line">        IsBalancedTree(root-&gt;left, &amp;left))&#123;</div><div class="line">        <span class="keyword">int</span> diff = left - right;</div><div class="line">        <span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff &gt;= <span class="number">-1</span>)&#123;</div><div class="line">            *pdepth = (left &gt; right ? left : right) + <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Solution</span><span class="params">(TreeNode* root)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> IsBalancedTree(root, &amp;depth);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ol>
<li><code>功能测试</code>（平衡二叉树，非平衡二叉树，二叉树所有的节点都没有左右子树）。</li>
<li><code>特殊测试用例</code>（二叉树中只有一个节点，二叉树根节点为NULL）</li>
</ol>
<h2 id="欢迎交流"><a href="#欢迎交流" class="headerlink" title="欢迎交流"></a>欢迎交流</h2><p>博客中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>
<ul>
<li>邮件(lyubinbinpku#163.com, 把#换成@)</li>
<li>QQ: 1257508426</li>
<li>weibo: <a href="http://weibo.com/lyricistpku" target="_blank" rel="external">@Lyricist勤Coding</a></li>
<li>github: <a href="https://github.com/LyricistPKU" target="_blank" rel="external">@LyricistPKU</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://LyricistPKU.github.io/2016/08/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
